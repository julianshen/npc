package main

import (
	"fmt"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

// FileDescriptorProto.package field number
const fileDescriptorProtoPackageFieldNumber = 2

// FileDescriptorProto.syntax field number
const fileDescriptorProtoSyntaxFieldNumber = 12

const deprecationComment = "// Deprecated: Do not use."

const natsPackage = protogen.GoImportPath("github.com/nats-io/nats.go")
const microPackage = protogen.GoImportPath("github.com/nats-io/nats.go/micro")
const protoPackage = protogen.GoImportPath("google.golang.org/protobuf/proto")
const timePackage = protogen.GoImportPath("time")

func genFile(f *protogen.File, gen *protogen.Plugin) {
	filename := f.GeneratedFilenamePrefix + "_npc.pb.go"
	g := gen.NewGeneratedFile(filename, f.GoImportPath)
	genLeadingComments(g, f.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
	g.P("// Code generated by protoc-gen-gonpc. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-gonpc v", version)
	g.P("// - protoc           ", protocVersion(gen))
	g.P()
	genLeadingComments(g, f.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoPackageFieldNumber}))
	g.P("package ", f.GoPackageName)
	g.P()

	for _, service := range f.Services {
		genService(g, service)
		genRegister(g, service)
		genClient(g, service)
	}
}

func genService(g *protogen.GeneratedFile, service *protogen.Service) {
	serverType := service.GoName + "Server"
	g.P("// ", serverType, " is the server API for ", service.GoName, " service.")
	g.AnnotateSymbol(serverType, protogen.Annotation{Location: service.Location})
	g.P(fmt.Sprintf("type %s interface {\n", serverType))

	//print full methods
	for _, method := range service.Methods {
		//fmt.Fprintf(os.Stderr, "%s %s %s\n", service.GoName, method.GoName, method.Input.GoIdent.GoName)
		g.AnnotateSymbol(serverType+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.P(deprecationComment)
		}
		g.P(method.Comments.Leading,
			clientSignature(g, method, false))
	}
	g.P("}")
	g.P()
}

func genRegister(g *protogen.GeneratedFile, service *protogen.Service) {
	serverType := service.GoName + "Server"
	g.P("func Register", service.GoName, "Server(conn *", natsPackage.Ident("Conn"), ", subject string", ",", strings.ToLower(service.GoName), " ", serverType, ") error {")
	g.P("srv, err := ", microPackage.Ident("AddService"), "(conn, ", microPackage.Ident("Config"), "{")
	g.P("Name: ", strconv.Quote(strings.ToLower(service.GoName)), ",")
	g.P("Version: \"1.0.0\",")
	g.P("})")
	g.P("if err != nil { return err }")
	g.P("grp := srv.AddGroup(subject)")
	for _, method := range service.Methods {
		g.P("grp.AddEndpoint(", strconv.Quote(strings.ToLower(method.GoName)), ",", microPackage.Ident("HandlerFunc"), " (func(r ", microPackage.Ident("Request"), ") {")
		g.P("req := &", method.Input.GoIdent, "{}")
		g.P(protoPackage.Ident("Unmarshal"), "(r.Data(), req)")
		g.P("resp := ", strings.ToLower(service.GoName), ".", method.GoName, "(req)")
		g.P("data, _ :=", protoPackage.Ident("Marshal"), "(resp)")
		g.P("r.Respond(data)")
		g.P("}))")
	}
	g.P("return nil")
	g.P("}")
	g.P()
}

func genClient(g *protogen.GeneratedFile, service *protogen.Service) {
	clientType := service.GoName + "Client"
	g.P(fmt.Sprintf("type %s struct {", clientType))
	g.P("subject string")
	g.P("timeout ", timePackage.Ident("Duration"))
	g.P("conn *", natsPackage.Ident("Conn"))
	g.P("}")

	g.P()
	g.P("func New", clientType, "(", "conn *", natsPackage.Ident("Conn"), ", subject string,", "timeout ", timePackage.Ident("Duration"), ") *", clientType, " {")
	g.P("return &", clientType, "{ subject, timeout, conn }")
	g.P("}")

	g.P()
	for _, method := range service.Methods {
		g.P("func (c *", clientType, ") ", clientSignature(g, method, true), "{")
		g.P("data, _ := ", protoPackage.Ident("Marshal"), "(in)")
		g.P("msg, err := ", "c.conn.Request(c.subject + \".", strings.ToLower(method.GoName), "\", data, c.timeout)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("reply := new (", g.QualifiedGoIdent(method.Output.GoIdent), ")")
		g.P(protoPackage.Ident("Unmarshal"), "(msg.Data, reply)")
		g.P("return reply, nil")
		g.P("}")
	}
}

func protocVersion(gen *protogen.Plugin) string {
	v := gen.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func clientSignature(g *protogen.GeneratedFile, method *protogen.Method, withErr bool) string {
	s := method.GoName + "(in *" + g.QualifiedGoIdent(method.Input.GoIdent) + ") "
	if withErr {
		s += "("
	}
	s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
	if withErr {
		s += ", error) "
	}
	return s
}

func genLeadingComments(g *protogen.GeneratedFile, loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}
